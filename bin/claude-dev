#!/usr/bin/env node

const { Command } = require('commander');
const chalk = require('chalk');
const readline = require('readline');
const { execSync } = require('child_process');
const { existsSync } = require('fs');
const { join } = require('path');

const program = new Command();

// Simple prompt replacement for inquirer
function promptUser(question, defaultValue = true) {
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    const defaultText = defaultValue ? ' (Y/n)' : ' (y/N)';
    rl.question(question + defaultText + ': ', (answer) => {
      rl.close();
      const result = answer.toLowerCase();
      if (result === '') {
        resolve(defaultValue);
      } else {
        resolve(result === 'y' || result === 'yes');
      }
    });
  });
}

program
  .name('claude-dev')
  .description('🚀 Claude Developer OS - Auto-orchestrated development environment')
  .version('1.0.0');

// 🚀 THE MAIN COMMAND
program
  .command('dev', { isDefault: true })
  .description('Start complete development environment')
  .option('-f, --fresh', 'Fresh start (clean all containers)')
  .option('-s, --silent', 'Silent mode (minimal output)')
  .option('--no-agents', 'Skip agent system initialization')
  .action(async (options) => {
    console.log(chalk.blue(`
╭─────────────────────────────────────────────────────────╮
│  🚀 Claude Developer OS - Auto-Orchestrated Environment │
│  AI Agents + Infrastructure + Cloud Sync               │  
╰─────────────────────────────────────────────────────────╯
`));

    try {
      // Check if Task runner is available
      const hasTask = checkCommand('task');
      if (!hasTask) {
        console.log(chalk.yellow('⚠️  Task runner not found. Install with: brew install go-task/tap/go-task'));
        console.log(chalk.blue('📋 Running basic setup instead...'));
      }

      // Phase 1: Project Analysis
      console.log(chalk.cyan('🔍 Analyzing project state...'));
      const analysis = await analyzeProject();
      
      if (options.fresh) {
        console.log(chalk.yellow('🧹 Fresh start requested - cleaning environment...'));
        await cleanInfrastructure();
      }

      // Phase 2: Environment Sync
      console.log(chalk.cyan('🔄 Synchronizing environments...'));
      if (hasTask && (existsSync('Taskfile.yml') || existsSync('tasks'))) {
        try {
          execSync('task sync:all', { stdio: 'inherit' });
        } catch (error) {
          console.log(chalk.yellow('⚠️  Task sync failed - using basic sync'));
          await basicEnvironmentSync();
        }
      } else {
        await basicEnvironmentSync();
      }

      // Phase 3: Infrastructure Startup
      console.log(chalk.cyan('🏗️  Starting infrastructure...'));
      if (hasTask && (existsSync('Taskfile.yml') || existsSync('tasks'))) {
        try {
          execSync('task infra:start', { stdio: 'inherit' });
        } catch (error) {
          console.log(chalk.yellow('⚠️  Task infra failed - using basic startup'));
          await startBasicInfrastructure();
        }
      } else {
        await startBasicInfrastructure();
      }

      // Phase 4: Health Check
      console.log(chalk.cyan('🏥 Performing health checks...'));
      const healthStatus = await checkBasicHealth();
      
      if (!healthStatus.healthy) {
        console.log(chalk.yellow('⚠️  Some services need attention:'));
        healthStatus.issues.forEach(issue => console.log(chalk.yellow(`   - ${issue}`)));
      }

      // Phase 5: Agent System Ready
      if (!options.noAgents) {
        console.log(chalk.cyan('🤖 Preparing agent system...'));
        
        // Create Claude Code subagents
        const agentScript = await findAgentScript();
        if (agentScript) {
          try {
            execSync(`bash "${agentScript}"`, { stdio: 'inherit' });
          } catch (error) {
            console.log(chalk.yellow('⚠️  Agent creation failed - continuing without agents'));
          }
        } else {
          console.log(chalk.yellow('⚠️  Agent creation script not found - continuing without agents'));
        }
        
        // Initialize product management systems and task files
        await initializeTaskSystem();
        
        if (checkCommand('task') && (existsSync('tasks') || existsSync('Taskfile.yml'))) {
          try {
            execSync('task queues:init', { stdio: 'pipe' });
            execSync('task roadmap:init', { stdio: 'pipe' });
            console.log(chalk.green('   ✅ Product management systems initialized'));
          } catch (error) {
            console.log(chalk.yellow('⚠️  Task-based initialization failed - using basic setup'));
            await initializeBasicProductManagement();
          }
        } else {
          await initializeBasicProductManagement();
        }
        
        // Check if repo is onboarded
        if (!analysis.agentSystemReady) {
          const shouldOnboard = await promptUser('Agent system not set up. Run repository onboarding?', true);
          
          if (shouldOnboard) {
            try {
              if (existsSync('scripts/repo-onboarding.sh')) {
                execSync('bash scripts/repo-onboarding.sh .', { stdio: 'inherit' });
              } else {
                console.log(chalk.yellow('⚠️  Onboarding script not found - skipping'));
              }
              
              // For existing codebases, run comprehensive audit
              if (analysis.hasExistingCode) {
                const shouldAudit = await promptUser('Existing codebase detected. Run comprehensive codebase audit?', true);
                
                if (shouldAudit) {
                  console.log(chalk.cyan('🔍 Running codebase audit with codebase-auditor agent...'));
                  try {
                    if (checkCommand('claude')) {
                      console.log(chalk.blue('🤖 Launching codebase audit...'));
                      // The audit will be performed by Claude Code CLI
                    } else {
                      console.log(chalk.yellow('⚠️  Claude Code CLI required for codebase audit'));
                    }
                  } catch (error) {
                    console.log(chalk.yellow('⚠️  Codebase audit failed - continuing without audit'));
                  }
                }
              }
            } catch (error) {
              console.log(chalk.yellow('⚠️  Onboarding failed - continuing without agents'));
            }
          }
        }
      }

      // Success!
      console.log(chalk.green(`
╭─── Development Environment Ready ───╮
│ ✅ Infrastructure: Started          │
│ ✅ Environment: Synchronized        │  
│ ✅ Health Check: Completed          │
│ ✅ Agent System: ${analysis.agentSystemReady ? 'Ready' : 'Available'}           │
╰──────────────────────────────────────╯

🌐 Local URLs:
   • App: http://localhost:3000
   • Database Studio: http://localhost:54323
   • API Gateway: http://localhost:54321
   • Monitoring: http://localhost:3001

🤖 Available Commands:
   • claude-dev status     # Check system health
   • claude-dev sync       # Sync environments
   • claude-dev deploy     # Deploy to production
   • claude-dev clean      # Clean environment

🚀 Claude Code Agent Integration:
   • claude --interactive  # Start Claude Code with agents ready
   • Use '/agents' command # Manage specialized subagents
   • Request agents by name: "Use task-executor agent to implement auth"

🎯 Product Management System:
   • Feature requests: "Use feature-intake-agent to add user profiles"
   • Queue management: "Use queue-manager agent to check task status"
   • Roadmap updates: "Use roadmap-manager agent to review priorities"
   • Admin oversight: "Use admin-dashboard-agent for system status"

${hasTask ? '📋 Task Commands:' : '⚠️  Install Task for advanced features:'}
${hasTask ? '   • task --list        # All available tasks' : '   • brew install go-task/tap/go-task'}
${hasTask ? '   • task health        # Check system health' : '   • Or use: claude-dev status (basic health check)'}
${hasTask ? '   • task queues:status # Check queue health' : ''}
${hasTask ? '   • task roadmap:view  # View product roadmap' : ''}

💡 Ready to code! Full development pipeline orchestrated with AI agents.
`));

    } catch (error) {
      console.error(chalk.red('❌ Failed to start development environment:'));
      console.error(chalk.red(error.message));
      
      console.log(chalk.yellow('\n🛠️  Try these troubleshooting steps:'));
      console.log(chalk.yellow('   1. Check Docker is running: docker info'));
      console.log(chalk.yellow('   2. Install Task: brew install go-task/tap/go-task'));
      console.log(chalk.yellow('   3. Clean and retry: claude-dev clean && claude-dev'));
      
      process.exit(1);
    }
  });

// 📊 Status Command
program
  .command('status')
  .description('Show complete system status')
  .action(async () => {
    console.log(chalk.blue('📊 System Status'));
    console.log(chalk.blue('================='));
    
    try {
      const analysis = await analyzeProject();
      const health = await checkBasicHealth();
      
      console.log(chalk.cyan('\n🏗️  Infrastructure:'));
      console.log(`   Framework: ${analysis.framework} (${analysis.language})`);
      console.log(`   Database: ${analysis.database ? '✅' : '❌'}`);
      console.log(`   Supabase: ${analysis.hasSupabase ? '✅' : '❌'}`);
      console.log(`   Vercel: ${analysis.hasVercel ? '✅' : '❌'}`);
      console.log(`   Docker: ${analysis.hasDocker ? '✅' : '❌'}`);
      
      console.log(chalk.cyan('\n🏥 Health Status:'));
      console.log(`   Docker: ${health.docker ? '✅' : '❌'}`);
      console.log(`   Application: ${health.app ? '✅' : '❌'}`);
      console.log(`   Task Runner: ${checkCommand('task') ? '✅' : '❌'}`);
      
      if (health.issues.length > 0) {
        console.log(chalk.yellow('\n⚠️  Issues:'));
        health.issues.forEach(issue => console.log(chalk.yellow(`   - ${issue}`)));
      }
      
    } catch (error) {
      console.error(chalk.red('❌ Failed to get system status:'));
      console.error(chalk.red(error.message));
    }
  });

// 🔄 Sync Command
program
  .command('sync')
  .description('Sync all environments and configurations')
  .action(async () => {
    console.log(chalk.blue('🔄 Synchronizing environments...'));
    
    try {
      if (checkCommand('task') && (existsSync('Taskfile.yml') || existsSync('tasks'))) {
        execSync('task sync:all', { stdio: 'inherit' });
      } else {
        await basicEnvironmentSync();
      }
      
      console.log(chalk.green('✅ Synchronization completed'));
      
    } catch (error) {
      console.error(chalk.red('❌ Synchronization failed:'));
      console.error(chalk.red(error.message));
    }
  });

// 🚀 Deploy Command
program
  .command('deploy')
  .description('Deploy to production')
  .option('-s, --staging', 'Deploy to staging instead')
  .action(async (options) => {
    const environment = options.staging ? 'staging' : 'production';
    
    console.log(chalk.blue(`🚀 Deploying to ${environment}...`));
    
    try {
      if (checkCommand('task') && (existsSync('Taskfile.yml') || existsSync('tasks'))) {
        if (options.staging) {
          execSync('task deploy:staging', { stdio: 'inherit' });
        } else {
          execSync('task deploy', { stdio: 'inherit' });
        }
      } else {
        await basicDeploy(environment);
      }
      
      console.log(chalk.green(`🎉 Deployment to ${environment} completed!`));
      
    } catch (error) {
      console.error(chalk.red(`❌ Deployment to ${environment} failed:`));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  });

// 🧹 Clean Command
program
  .command('clean')
  .description('Clean development environment')
  .option('--hard', 'Hard clean (remove all containers and volumes)')
  .action(async (options) => {
    console.log(chalk.yellow('🧹 Cleaning development environment...'));
    
    try {
      await cleanInfrastructure(options.hard);
      console.log(chalk.green('✅ Environment cleaned'));
      
    } catch (error) {
      console.error(chalk.red('❌ Cleaning failed:'));
      console.error(chalk.red(error.message));
    }
  });

// 🛠️ Setup Command
program
  .command('setup')
  .description('Initial project setup and configuration')
  .action(async () => {
    console.log(chalk.blue('🛠️  Setting up Claude Developer OS...'));
    
    try {
      await setupProject();
      console.log(chalk.green('✅ Setup completed! Run "claude-dev" to start.'));
      
    } catch (error) {
      console.error(chalk.red('❌ Setup failed:'));
      console.error(chalk.red(error.message));
    }
  });

// Helper Functions
function checkCommand(command) {
  try {
    execSync(`command -v ${command}`, { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

async function analyzeProject() {
  const analysis = {
    framework: 'Unknown',
    language: 'Unknown',
    database: false,
    hasSupabase: false,
    hasVercel: false,
    hasDocker: false,
    agentSystemReady: false,
    hasExistingCode: false
  };

  // Detect framework and language
  if (existsSync('package.json')) {
    try {
      const pkg = require(join(process.cwd(), 'package.json'));
      
      if (pkg.dependencies?.next) analysis.framework = 'Next.js';
      else if (pkg.dependencies?.react) analysis.framework = 'React';
      else if (pkg.dependencies?.express) analysis.framework = 'Express';
      else analysis.framework = 'Node.js';
      
      analysis.language = 'JavaScript';
      if (pkg.dependencies?.typescript || pkg.devDependencies?.typescript) {
        analysis.language = 'TypeScript';
      }
    } catch (error) {
      console.warn(chalk.yellow('⚠️  Could not parse package.json'));
    }
  }

  // Check infrastructure components
  analysis.hasSupabase = existsSync('supabase/config.toml');
  analysis.hasVercel = existsSync('.vercel/project.json');
  analysis.hasDocker = existsSync('docker-compose.yml') || existsSync('docker-compose.dev.yml');
  analysis.database = analysis.hasSupabase || existsSync('prisma');
  analysis.agentSystemReady = existsSync('PROJECT_MANIFESTO.md');
  
  // Check for existing codebase (look for common source directories)
  analysis.hasExistingCode = existsSync('src') || existsSync('lib') || existsSync('app') || 
                           existsSync('components') || existsSync('pages') || existsSync('routes') ||
                           existsSync('models') || existsSync('services') || existsSync('controllers');

  return analysis;
}

async function checkBasicHealth() {
  const health = {
    healthy: true,
    docker: false,
    app: false,
    issues: []
  };

  // Check Docker
  try {
    execSync('docker info', { stdio: 'pipe' });
    health.docker = true;
  } catch {
    health.issues.push('Docker not running');
  }

  // Check if app is responding
  try {
    const response = await fetch('http://localhost:3000').catch(() => null);
    health.app = response?.ok || false;
  } catch {
    health.issues.push('Application not responding on port 3000');
  }

  health.healthy = health.issues.length === 0;
  return health;
}

async function basicEnvironmentSync() {
  console.log(chalk.blue('📝 Basic environment sync...'));
  
  // Create .env from .env.example if it exists
  if (existsSync('.env.example') && !existsSync('.env')) {
    execSync('cp .env.example .env');
    console.log(chalk.green('   ✅ Created .env from .env.example'));
  }
  
  // Pull Vercel env if available
  if (checkCommand('vercel') && existsSync('.vercel/project.json')) {
    try {
      execSync('vercel env pull .env.vercel', { stdio: 'pipe' });
      console.log(chalk.green('   ✅ Pulled Vercel environment'));
    } catch {
      console.log(chalk.yellow('   ⚠️  Could not pull Vercel environment'));
    }
  }
}

async function startBasicInfrastructure() {
  console.log(chalk.blue('🚀 Starting basic infrastructure...'));
  
  // Start Docker Compose if available
  if (checkCommand('docker')) {
    const composeFile = existsSync('docker-compose.dev.yml') ? 'docker-compose.dev.yml' : 'docker-compose.yml';
    
    if (existsSync(composeFile)) {
      try {
        execSync(`docker-compose -f ${composeFile} up -d`, { stdio: 'inherit' });
        console.log(chalk.green('   ✅ Docker Compose started'));
      } catch (error) {
        console.log(chalk.yellow('   ⚠️  Docker Compose failed to start'));
      }
    }
  }
  
  // Start Supabase if available
  if (checkCommand('supabase') && existsSync('supabase/config.toml')) {
    try {
      execSync('supabase start', { stdio: 'inherit' });
      console.log(chalk.green('   ✅ Supabase started'));
    } catch {
      console.log(chalk.yellow('   ⚠️  Supabase already running or failed to start'));
    }
  }
}

async function basicDeploy(environment) {
  console.log(chalk.blue(`🚀 Basic deployment to ${environment}...`));
  
  if (checkCommand('vercel')) {
    try {
      if (environment === 'production') {
        execSync('vercel --prod', { stdio: 'inherit' });
      } else {
        execSync('vercel', { stdio: 'inherit' });
      }
      console.log(chalk.green('   ✅ Vercel deployment completed'));
    } catch (error) {
      throw new Error('Vercel deployment failed');
    }
  } else {
    throw new Error('Vercel CLI not found - install with: npm i -g vercel');
  }
}

async function cleanInfrastructure(hard = false) {
  console.log(chalk.blue('🧹 Cleaning infrastructure...'));
  
  if (checkCommand('docker')) {
    const composeFile = existsSync('docker-compose.dev.yml') ? 'docker-compose.dev.yml' : 'docker-compose.yml';
    
    if (existsSync(composeFile)) {
      execSync(`docker-compose -f ${composeFile} down${hard ? ' -v' : ''}`, { stdio: 'inherit' });
    }
    
    if (hard) {
      execSync('docker system prune -a -f --volumes', { stdio: 'inherit' });
    }
  }
}

async function setupProject() {
  console.log(chalk.blue('📦 Setting up project dependencies...'));
  
  // Install npm dependencies if package.json exists
  if (existsSync('package.json')) {
    if (existsSync('pnpm-lock.yaml')) {
      execSync('pnpm install', { stdio: 'inherit' });
    } else if (existsSync('yarn.lock')) {
      execSync('yarn install', { stdio: 'inherit' });
    } else {
      execSync('npm install', { stdio: 'inherit' });
    }
  }
  
  // Initialize git if not already
  if (!existsSync('.git')) {
    execSync('git init', { stdio: 'inherit' });
  }
  
  // Create basic directories
  ['logs', 'tmp', '.claude'].forEach(dir => {
    if (!existsSync(dir)) {
      execSync(`mkdir -p ${dir}`);
    }
  });
}

function findSourcePath() {
  // Find the claude-code-agent-system directory
  const possiblePaths = [
    // If running from the repo directly  
    __dirname.includes('claude-code-agent-system') ? join(__dirname, '..') : null,
    // If installed globally
    join(process.env.NODE_PATH || '', 'claude-code-agent-system'),
    // If in node_modules
    join(process.cwd(), 'node_modules', 'claude-code-agent-system'), 
    // Common locations
    join(process.env.HOME || '', '.claude-code-agent-system'),
    join('/usr/local/lib', 'claude-code-agent-system'),
    // Global npm install location
    '/usr/local/lib/node_modules/claude-code-agent-system'
  ].filter(Boolean);
  
  for (const path of possiblePaths) {
    if (existsSync(path) && existsSync(join(path, 'Taskfile.yml'))) {
      return path;
    }
  }
  return null;
}

async function findAgentScript() {
  const sourcePath = findSourcePath();
  if (sourcePath) {
    const scriptPath = join(sourcePath, 'scripts', 'create-claude-agents.sh');
    if (existsSync(scriptPath)) {
      return scriptPath;
    }
  }
  
  // Fallback to local check
  if (existsSync('scripts/create-claude-agents.sh')) {
    return 'scripts/create-claude-agents.sh';
  }
  
  return null;
}

async function initializeTaskSystem() {
  console.log(chalk.blue('📋 Setting up task management system...'));
  
  const sourcePath = findSourcePath();
  
  if (sourcePath) {
    // Copy Taskfile.yml if it doesn't exist
    if (!existsSync('Taskfile.yml')) {
      try {
        execSync(`cp "${join(sourcePath, 'Taskfile.yml')}" Taskfile.yml`);
        console.log(chalk.green('   ✅ Taskfile.yml copied'));
      } catch (error) {
        console.log(chalk.yellow('   ⚠️  Could not copy Taskfile.yml'));
      }
    }
    
    // Copy tasks directory if it doesn't exist
    if (!existsSync('tasks') && existsSync(join(sourcePath, 'tasks'))) {
      try {
        execSync(`cp -r "${join(sourcePath, 'tasks')}" tasks`);
        console.log(chalk.green('   ✅ Task definitions copied'));
      } catch (error) {
        console.log(chalk.yellow('   ⚠️  Could not copy task definitions'));
      }
    }
  } else {
    console.log(chalk.yellow('   ⚠️  Claude Code Agent System source not found - using basic setup'));
  }
}

async function initializeBasicProductManagement() {
  console.log(chalk.blue('📋 Setting up basic product management...'));
  
  // Create QUEUES directory and basic queue files
  if (!existsSync('QUEUES')) {
    execSync('mkdir -p QUEUES');
    
    // Create basic queue files
    const queues = ['urgent', 'feature-dev', 'maintenance', 'research', 'admin'];
    queues.forEach(queueName => {
      const queueFile = `QUEUES/${queueName}.json`;
      if (!existsSync(queueFile)) {
        const queueData = {
          queue: {
            name: queueName,
            sla_hours: queueName === 'urgent' ? 2 : queueName === 'feature-dev' ? 120 : 24,
            auto_assign: true,
            max_concurrent: queueName === 'urgent' ? 5 : 10
          },
          tasks: [],
          metrics: {
            total_tasks: 0,
            completed_tasks: 0,
            sla_compliance_rate: 100,
            current_load: 0
          },
          agents: {
            preferred: queueName === 'urgent' ? ['task-executor', 'security-auditor'] : ['task-executor'],
            available: [],
            busy: []
          }
        };
        
        execSync(`echo '${JSON.stringify(queueData, null, 2)}' > "${queueFile}"`);
      }
    });
    console.log(chalk.green('   ✅ Queue system initialized'));
  }
  
  // Create basic roadmap if it doesn't exist
  if (!existsSync('ROADMAP.md')) {
    const roadmapContent = `# Product Roadmap

*Last updated: ${new Date().toISOString().split('T')[0]} by roadmap-manager*

## Current Release: v1.0.0

### 🎯 Active Development (Current Sprint)

| Feature | Priority | Status | Assigned Agent | ETA | Dependencies |
|---------|----------|--------|----------------|-----|--------------|
| System Setup | High | In Progress | claude-dev | Today | - |

### 📋 Next Up (Planned)

Planning phase - add features through feature-intake-agent

### 🔮 Future Releases

To be determined based on feature requests

### 📊 Progress Metrics

- **Completed Features This Quarter**: 0
- **Average Delivery Time**: Establishing baseline
- **Current Velocity**: Initial setup
- **Queue Health**: All queues operational

---

*This roadmap is actively managed by the roadmap-manager agent.*`;
    
    execSync(`echo '${roadmapContent}' > ROADMAP.md`);
    console.log(chalk.green('   ✅ Roadmap initialized'));
  }
  
  // Create feature intake file - find and copy from templates
  if (!existsSync('FEATURE_INTAKE.md')) {
    const templateContent = `# Feature Intake System

*Managed by: feature-intake-agent*

## 🎯 How to Submit Feature Requests

### Via Claude Code Agent
\`\`\`
"I need to request a new feature: [describe your feature]"
# The feature-intake-agent will automatically process your request
\`\`\`

### Via Direct Request
Use the following format for feature requests:

**Title**: Brief, descriptive name  
**Description**: Detailed explanation of the feature  
**Business Justification**: Why this feature is needed  
**Priority**: Low/Medium/High/Critical  

## 📋 Intake Process

The feature-intake-agent follows this process:

1. **Initial Validation** - Complete information and feasibility check
2. **Effort Estimation** - Small/Medium/Large/Epic sizing  
3. **Queue Routing** - Route to appropriate queue based on priority
4. **Stakeholder Notification** - Confirm receipt and provide tracking

## 🤖 Agent Integration

Use agents naturally:
- "Use the feature-intake-agent to process this request"
- "Have the roadmap-manager agent update priorities"
- "Ask the queue-manager agent about current workload"

---

*Feature intake system ensures all requests are captured and routed efficiently.*`;
    
    execSync(`echo '${templateContent}' > FEATURE_INTAKE.md`);
    console.log(chalk.green('   ✅ Feature intake system ready'));
  }
}

// Handle unknown commands
program.on('command:*', () => {
  console.error(chalk.red('❌ Invalid command: %s\nSee --help for a list of available commands.'), program.args.join(' '));
  process.exit(1);
});

// Show help if no command provided, or run dev as default
if (!process.argv.slice(2).length) {
  // Run dev command as default
  program.parse(['node', 'claude-dev', 'dev']);
} else {
  // Parse provided arguments
  program.parse();
}